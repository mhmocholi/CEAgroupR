---
title: "Tutorial de uso del paquete CEAgroupR"
author: "Miguel Ángel Hernández Mocholí"
date: "`r format(Sys.Date(), '%d/%m/%Y')`"
output:
  html_document:
    toc: true               
    toc_float: true         
    toc_depth: 3            
    number_sections: true   
    theme: united           
    highlight: tango        
    code_folding: show      
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

# Cargar el paquete en desarrollo directamente desde el código fuente
devtools::load_all()
library(magrittr)
```

# Introducción

Este documento ofrece una guía práctica para el uso del paquete CEAgroupR, desarrollado para realizar análisis de coste-efectividad (CEA) y coste-utilidad (CUA) en R.
El paquete permite trabajar con múltiples datasets y subgrupos, generando resultados comparables, reproducibles y visualmente consistentes.

El flujo de trabajo se estructura en tres capas:

-   Capa analítica – Realiza el bootstrap no paramétrico y calcula las métricas incrementales.

-   Capa de integración – Combina los resultados y mantiene su trazabilidad.

-   Capa de visualización – Ofrece funciones gráficas consistentes y flexibles para interpretar los resultados.

# Análisis exploratorio de los datos

Antes de iniciar el análisis de coste-utilidad, se recomienda realizar una exploración descriptiva básica de los datos.
En este apartado se generan datasets simulados y se describen las variables principales (costes, efectos, subgrupos).

```{r exploratory}
set.seed(123)
data_A <- data.frame(
  group = rep(c("Control", "Intervention"), each = 200),
  cost = c(rnorm(200, 5200, 900), rnorm(200, 6100, 950)),
  effect = c(rnorm(200, 6.8, 0.6), rnorm(200, 7.1, 0.5)),
  sex = sample(c("Male", "Female"), 400, TRUE)
)

data_B <- data.frame(
  group = rep(c("Control", "Intervention"), each = 200),
  cost = c(rnorm(200, 5100, 800), rnorm(200, 6500, 900)),
  effect = c(rnorm(200, 6.9, 0.5), rnorm(200, 7.3, 0.4)),
  sex = sample(c("Male", "Female"), 400, TRUE)
)

data_list <- list(Dataset_A = data_A, Dataset_B = data_B)

summary(data_A)
summary(data_B)
```

# Capa analítica: función compute_icers()

La función compute_icers() constituye el núcleo de la capa analítica.
Realiza el bootstrap no paramétrico y calcula las métricas incrementales:

Coste incremental (ΔCost)

Efecto incremental (ΔEffect)

ICER (Incremental Cost-Effectiveness Ratio)

NMB (Net Monetary Benefit)

Además, conserva la información de subgrupos, réplicas y parámetros de análisis.

```{r compute}
results_two <- compute_icers(
  data = data_list,
  group = "group",
  cost = "cost",
  effect = "effect",
  R = 500,
  lambda = c(25000, 35000),
  subgroup_vars = c("sex")
)
names(results_two)
head(results_two$combined_replicates)
```

# Capa de integración

Los resultados bootstrap de cada dataset y subgrupo se combinan mediante la función combine_icers_results(), generando un único objeto estructurado.
Este objeto constituye la base para todas las representaciones gráficas del paquete.

```{r integration}
results_two$combined_replicates %>%
  dplyr::group_by(dataset, subgroup_var, subgroup_level) %>%
  dplyr::summarise(
    mean_cost = mean(Delta_Cost, na.rm = TRUE),
    mean_effect = mean(Delta_Effect, na.rm = TRUE)
  )
```

# Capa de visualización

Esta capa incluye tres funciones principales de representación:

plot.icers() — plano coste-efectividad (ICER).

plot.ceacs() — curvas de aceptabilidad coste-efectiva (CEAC).

plot.evpis() — valor esperado de la información perfecta (EVPI).

plot.distribution() — distribuciones incrementales de ΔCost o ΔEffect.

Cada función comparte los mismos argumentos de mapeo estético (color_by, shape_by, facet_by) y el parámetro mode, que define el nivel de detalle visualizado.

## Plano coste-efectividad (ICER)

Representa las réplicas bootstrap en el plano coste-efecto, junto con las medias incrementales y los contornos de confianza.
Permite comparar datasets y subgrupos, mostrando las regiones de dominancia y las curvas de disposición a pagar (λ).

En este primer ejemplo se muestran los contornos utilizando el typo "ellipse" que genera dichos contornos utilizando un método parametrico consistente en determina la ellipse de menor area que contiene una proporción determinada (0.95 como valor por defecto) de las respectivas nubes de puntos

```{r icers1}
plot.icers(results_two, mode = "Full", show_contours = TRUE, contour_type = "ellipse")
```

En el segundo ejemplo se observan los contornos generados en las mismas condiciones del ejemplo anteriore salvo por la utilización ddel tipo "non_parametric" basados en la estimación de la densidad Kernel Density Estimation.

```{r icers2}
plot.icers(results_two, mode = "Full", show_contours = TRUE, contour_type = "non_parametric")
```

Como ultimo ejemplo respecto a los contornos, se observan los ejemplos anteriores empleando un vector de probabilidades definiendo "contour_level" en el que se aprecian los distintos contornos generdos para cada nube de puntos

```{r icers3}
plot.icers(results_two, mode = "Subgroups", show_contours = TRUE, contour_type = "ellipse", contour_level = c(0.5,0.9,0.95))
```

```{r icers4}
plot.icers(results_two, mode = "Subgroups", show_contours = TRUE, contour_type = "non_parametric", contour_level = c(0.5,0.9,0.95))
```

## Curvas de aceptabilidad (CEAC)

Muestran la probabilidad empírica de que una estrategia sea coste-efectiva para distintos valores de λ.
Cada curva representa un dataset o un subgrupo, y el modo de visualización define el nivel de detalle mostrado.

```{r ceac}
plot.ceacs(results_two, mode = "Full")
```

## Valor esperado de la información perfecta (EVPI)

El gráfico EVPI muestra el valor monetario esperado de eliminar la incertidumbre del modelo, calculado a partir de las réplicas bootstrap.
Ayuda a priorizar la obtención de información adicional cuando el valor esperado de la información es elevado.

```{r evpi}
plot.evpis(results_two, mode = "Full")
```

## Distribuciones marginales

La función plot.distribution() permite explorar la distribución marginal de los resultados incrementales (ΔCost o ΔEffect).
Es útil para identificar sesgos, asimetrías o diferencias significativas entre subgrupos.

La función admite diferentes tipos de geometrías (histogram, density, boxplot) y un argumento compare = TRUE que añade líneas de comparación estadística entre grupos (solo en mode = "Subgroups").

```{r distributions}
plot.distribution(results_two, variable = "cost", geom_type = "histogram",mode = "Subgroups", compare = TRUE)
plot.distribution(results_two, variable = "effect", geom_type = "density",mode = "Subgroups", compare = TRUE)
plot.distribution(results_two, variable = "cost", geom_type = "boxplot", mode = "Subgroups", compare = TRUE)
plot.distribution(results_two, variable = "effect", geom_type = "boxplot", mode = "Subgroups", compare = TRUE)

```

# Modos de visualización

Todas las funciones gráficas comparten el argumento mode, que define el nivel de agregación:

"Overall" — muestra únicamente los resultados globales por dataset.

"Subgroups" — representa los resultados desglosados por subgrupos.

"Full" — combina los resultados globales y de subgrupos en un mismo gráfico.

Estos modos pueden combinarse con los argumentos color_by, shape_by y facet_by para personalizar completamente la representación.

```{r modes}
plot.icers(results_two, mode = "Overall")
plot.icers(results_two, mode = "Subgroups")
plot.icers(results_two, mode = "Full")
```

# Conclusiones

El paquete CEAgroupR ofrece una estructura modular, transparente y extensible para la evaluación económica en salud.
Permite realizar análisis coste-efectividad reproducibles con soporte explícito para subgrupos, garantizando la coherencia visual y la trazabilidad de los resultados.

# Referencias

Briggs AH, Claxton K, Sculpher MJ (2006).
Decision Modelling for Health Economic Evaluation.
Oxford University Press.

NICE (2013).
Guide to the Methods of Technology Appraisal.

Zhuang, M.
et al. (2022).
Health Economic Evaluation in R: A Practical Guide.
