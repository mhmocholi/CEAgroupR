#' Plot Incremental Cost-Effectiveness (ICER) Plane
#'
#' Produces the incremental cost-effectiveness (CE) plane based on bootstrap
#' replicates generated by \code{\link{compute_icers}}. The CE plane displays
#' incremental effectiveness on the x-axis and incremental cost on the y-axis,
#' providing a graphical representation of joint uncertainty in costs and
#' effects for competing strategies.
#'
#' The function supports multi-strategy and multi-dataset analyses, explicit
#' subgroup stratification, and flexible aesthetic mappings. It is designed as
#' the primary visualization tool for exploring uncertainty, dominance and
#' variability in cost-effectiveness analyses.
#'
#' The plot may include:
#' \itemize{
#'   \item bootstrap replicate clouds,
#'   \item mean incremental outcomes,
#'   \item non-parametric or elliptical confidence contours,
#'   \item willingness-to-pay (WTP) reference lines.
#' }
#'
#' @param data Either the output of \code{\link{compute_icers}} or a tibble
#'   produced by \code{\link{combine_icers_results}} containing bootstrap
#'   replicates.
#'
#' @param color_by Character string specifying the variable used for colour
#'   mapping. Use \code{"none"} to disable colour mapping. Defaults to
#'   \code{"comparison"}.
#'
#' @param shape_by Character string specifying the variable used for point
#'   shape mapping. Use \code{"none"} to disable shape mapping. Defaults to
#'   \code{"dataset"}.
#'
#' @param facet_by Character string defining the faceting directive. Supported
#'   values include \code{"dataset"}, \code{"comparison"},
#'   \code{"subgroup_var"}, \code{"subgroup_level"}, or \code{"subgroup"} to
#'   construct a grid of subgroup-variable by subgroup-level. Use
#'   \code{"none"} to disable faceting.
#'
#' @param mode Character string specifying whether to display results for the
#'   overall population (\code{"Overall"}) or subgroup-specific analyses
#'   (\code{"Subgroups"}).
#'
#' @param filter_expr Optional tidyverse-style filtering expression applied to
#'   the underlying bootstrap replicates prior to plotting.
#'
#' @param show_points Logical; if \code{TRUE}, displays the bootstrap replicate
#'   cloud.
#'
#' @param show_means Logical; if \code{TRUE}, overlays mean incremental
#'   outcomes for each comparison.
#'
#' @param show_contours Logical; if \code{TRUE}, adds confidence contours based
#'   on bootstrap replicates.
#'
#' @param show_lambdas Logical; if \code{TRUE}, displays willingness-to-pay
#'   reference lines when available.
#'
#' @param label_lambdas Logical; if \code{TRUE}, labels willingness-to-pay
#'   reference lines.
#'
#' @param contour_type Character string specifying the type of contour to draw
#'   (\code{"non_parametric"} or \code{"ellipse"}).
#'
#' @param contour_level Numeric value or vector specifying the probability mass
#'   covered by confidence contours (e.g. \code{0.95}).
#'
#' @param facet_scales Character string specifying whether facet scales are
#'   fixed or free (passed to \code{ggplot2}).
#'
#' @param palette Colour palette name or vector passed to
#'   \code{\link{ce_plot_base}}.
#'
#' @param shapes_palette Optional object of class \code{"cea_shapes"} defining
#'   custom shape values for point layers.
#'
#' @param ... Additional graphical parameters passed to point layers
#'   (e.g. \code{alpha}, \code{size}).
#'
#' @details
#' This function is tightly integrated with the internal plotting engine
#' \code{\link{ce_plot_base}} and is fully compatible with the other graphical
#' functions in CEAgroupR. It is typically used as the main exploratory tool
#' for visualizing uncertainty and dominance relationships in cost-effectiveness
#' analyses.
#'
#' @return
#' A \code{ggplot} object representing the incremental cost-effectiveness plane.
#'
#' @examples
#' ## Example 1: Basic ICER plane for a single dataset
#' res <- compute_icers(
#'   data      = cua_base,
#'   group     = "group",
#'   cost      = "cost_total",
#'   effect    = "effect",
#'   ref_group = "g0",
#'   R         = 50,
#'   seed      = 123
#' )
#'
#' plot.icers(res)
#'
#' ## Example 2: ICER plane with contours and subgroup stratification
#' plot.icers(
#'   res,
#'   show_contours = TRUE,
#'   mode          = "Subgroups",
#'   facet_by      = "subgroup"
#' )
#' @export plot.icers
#' @export
plot.icers <- function(
    data,
    color_by      = NULL,
    shape_by      = NULL,
    facet_by      = NULL,
    mode          = "Overall",
    filter_expr   = NULL,
    show_points   = TRUE,
    show_means    = TRUE,
    show_contours = FALSE,
    show_lambdas  = TRUE,
    label_lambdas = FALSE,
    contour_type  = "non_parametric",
    contour_level = 0.95,
    facet_scales  = "fixed",
    palette       = "Dark2",
    shapes_palette = NULL,
    ...
) {

  `%||%` <- function(a, b) if (!is.null(a)) a else b

  # ========================================================================
  # 1. Extract data
  # ========================================================================
  if (inherits(data, "cea_results_list")) {
    df          <- data$combined_replicates
    lambda_vals <- data$settings$lambda
  } else {
    df          <- data
    lambda_vals <- NULL
  }

  if (!"group_uid" %in% names(df)) {
    df$group_uid <- with(
      df,
      paste(dataset, subgroup_var, subgroup_level, comparison, sep = "_")
    )
  }

  # ========================================================================
  # 2. Filtering
  # ========================================================================
  if (!is.null(filter_expr)) {
    df <- dplyr::filter(df, !!rlang::parse_expr(filter_expr))
  }

  # ========================================================================
  # 3. Mode filtering
  # ========================================================================
  mode <- match.arg(mode, c("Overall", "Subgroups"))

  if (mode == "Overall") {
    df <- df[df$subgroup_var == "Overall" | is.na(df$subgroup_var), ]
  } else {
    df <- df[df$subgroup_var != "Overall" & !is.na(df$subgroup_var), ]
  }

  # ========================================================================
  # 4. Default aesthetic mappings
  # ========================================================================
  default_color <- "comparison"
  default_shape <- "dataset"
  default_facet <- if (mode == "Subgroups") "subgroup" else "none"

  resolved_color <- color_by %||% default_color
  resolved_shape <- shape_by %||% default_shape
  resolved_facet <- facet_by %||% default_facet

  if (identical(color_by, "none")) resolved_color <- NULL
  if (identical(shape_by, "none")) resolved_shape <- NULL
  if (identical(facet_by, "none")) resolved_facet <- NULL

  # ========================================================================
  # 5. Base layout via ce_plot_base()
  # ========================================================================
  base <- ce_plot_base(
    data           = df,
    color_by       = resolved_color,
    shape_by       = resolved_shape,
    facet_by       = resolved_facet,
    facet_scales   = facet_scales,
    palette        = palette,
    shapes_palette = shapes_palette
  )

  p             <- base$plot
  color_var     <- base$color_var
  shape_var     <- base$shape_var
  palette_vals  <- base$palette_values
  shape_vals    <- base$shape_values
  linetype_vals <- base$linetype_values

  valid_color <- !is.null(color_var)
  valid_shape <- !is.null(shape_var)

  # ========================================================================
  # 6. Colour scale
  # ========================================================================
  if (valid_color) {

    lvls <- unique(df[[color_var]])
    pal  <- palette_vals

    if (is.null(names(pal))) {
      pal <- rep(pal, length.out = length(lvls))
      names(pal) <- lvls
    }

    color_map <- pal[lvls]
    p <- p + ggplot2::scale_colour_manual(values = color_map)

  } else {
    color_map <- c(fixed = palette_vals[1])
  }

  # ========================================================================
  # 7. Shape scale (points and means only)
  # ========================================================================
  if (valid_shape) {
    if (!is.null(shape_vals)) {
      p <- p + ggplot2::scale_shape_manual(values = shape_vals)
    } else {
      p <- p + ggplot2::scale_shape_discrete()
    }
  }

  # ========================================================================
  # 8. Axes
  # ========================================================================
  p <- p +
    ggplot2::geom_hline(yintercept = 0, colour = "grey70", linetype = "dashed") +
    ggplot2::geom_vline(xintercept = 0, colour = "grey70", linetype = "dashed")

  # ========================================================================
  # 9. Legend cleanup
  # ========================================================================
  if (valid_color &&
      dplyr::n_distinct(df[[color_var]]) == 1) {
    p <- p + ggplot2::guides(colour = "none")
  }

  if (valid_shape &&
      dplyr::n_distinct(df[[shape_var]]) == 1) {
    p <- p + ggplot2::guides(shape = "none")
  }

  # ========================================================================
  # 10. Bootstrap clouds
  # ========================================================================
  if (show_points) {

    usr <- list(...)

    n_rep <- dplyr::n_distinct(df$replicate)
    alpha_auto <- min(0.9, max(0.3, 0.9 - 0.25 * log10(n_rep / 100)))

    alpha_val <- usr$alpha %||% alpha_auto
    size_val  <- usr$size  %||% 1.2

    aes_cloud <- ggplot2::aes(
      x = Delta_Effect,
      y = Delta_Cost
    )
    if (valid_color) aes_cloud$colour <- rlang::sym(color_var)
    if (valid_shape) aes_cloud$shape  <- rlang::sym(shape_var)

    p <- p +
      ggplot2::geom_point(
        data        = df,
        mapping     = aes_cloud,
        alpha       = alpha_val,
        size        = size_val,
        show.legend = TRUE
      )
  }

  # ========================================================================
  # 11. Contours
  # ========================================================================
  if (show_contours) {

    contour_type  <- match.arg(contour_type, c("non_parametric", "ellipse"))
    contour_level <- pmin(pmax(contour_level, 0.001), 0.999)

    for (gid in unique(df$group_uid)) {

      sub <- df[df$group_uid == gid, ]
      if (nrow(sub) < 30) next

      color_key <- if (valid_color) as.character(unique(sub[[color_var]])[1]) else "fixed"
      col_ct    <- colorspace::darken(color_map[[color_key]], 0.55)

      if (valid_shape) {
        shape_key <- as.character(unique(sub[[shape_var]])[1])
        lt_ct     <- linetype_vals[shape_key]
      } else {
        lt_ct <- "solid"
      }

      if (contour_type == "non_parametric") {

        dens <- MASS::kde2d(sub$Delta_Effect, sub$Delta_Cost, n = 200)

        grid <- expand.grid(
          Delta_Effect = dens$x,
          Delta_Cost   = dens$y
        )
        grid$z <- as.vector(dens$z)

        dx <- diff(dens$x)[1]
        dy <- diff(dens$y)[1]

        z_sorted <- sort(grid$z, decreasing = TRUE)
        cum_vol  <- cumsum(z_sorted) * dx * dy

        for (lvl in contour_level) {
          idx <- which(cum_vol >= lvl)[1]
          threshold <- z_sorted[idx]

          p <- p +
            ggplot2::geom_contour(
              data        = grid,
              mapping     = ggplot2::aes(
                x = Delta_Effect,
                y = Delta_Cost,
                z = z
              ),
              breaks      = threshold,
              colour      = col_ct,
              linetype    = lt_ct,
              linewidth   = 0.6,
              inherit.aes = FALSE,
              show.legend = FALSE
            )
        }

      } else {

        mu <- colMeans(sub[, c("Delta_Effect", "Delta_Cost")], na.rm = TRUE)
        cv <- stats::cov(sub[, c("Delta_Effect", "Delta_Cost")], use = "pairwise")
        eg <- eigen(cv)

        for (lvl in contour_level) {

          chi <- sqrt(stats::qchisq(lvl, df = 2))
          t   <- seq(0, 2 * pi, length.out = 200)

          xy <- t(mu + eg$vectors %*%
                    (sqrt(eg$values) * chi *
                       rbind(cos(t), sin(t))))

          p <- p +
            ggplot2::geom_path(
              data = data.frame(
                Delta_Effect = xy[, 1],
                Delta_Cost   = xy[, 2]
              ),
              mapping     = ggplot2::aes(Delta_Effect, Delta_Cost),
              colour      = col_ct,
              linetype    = lt_ct,
              linewidth   = 0.6,
              inherit.aes = FALSE,
              show.legend = FALSE
            )
        }
      }
    }
  }

  # ========================================================================
  # 12. Mean points
  # ========================================================================
  if (show_means) {

    means <- df %>%
      dplyr::group_by(dataset, subgroup_var, subgroup_level,
                      comparison, group_uid) %>%
      dplyr::summarise(
        Delta_Effect = mean(Delta_Effect, na.rm = TRUE),
        Delta_Cost   = mean(Delta_Cost,   na.rm = TRUE),
        colour_key   = if (valid_color) dplyr::first(.data[[color_var]])
        else "fixed",
        shape_key    = if (valid_shape) dplyr::first(.data[[shape_var]])
        else "fixed",
        .groups      = "drop"
      )

    means$fill_col   <- color_map[means$colour_key]
    means$border_col <- colorspace::darken(means$fill_col, 0.55)

    p <- p +
      ggplot2::geom_point(
        data = means,
        mapping = ggplot2::aes(
          x = Delta_Effect,
          y = Delta_Cost,
          shape = shape_key,
          group = group_uid
        ),
        fill        = means$fill_col,
        colour      = means$border_col,
        size        = 2.5,
        stroke      = 1,
        inherit.aes = FALSE,
        show.legend = FALSE
      )
  }

  # ========================================================================
  # 13. WTP lambda lines
  # ========================================================================
  if (show_lambdas && !is.null(lambda_vals)) {

    for (l in lambda_vals) {
      p <- p + ggplot2::geom_abline(
        slope     = l,
        intercept = 0,
        colour    = "grey45",
        linetype  = "dashed",
        linewidth = 0.6
      )
    }

    if (label_lambdas) {

      max_x <- max(df$Delta_Effect, na.rm = TRUE)

      df_lab <- data.frame(
        x     = max_x * 0.85,
        y     = lambda_vals * max_x,
        label = paste0("lambda = ", lambda_vals)
      )

      p <- p +
        ggplot2::geom_text(
          data    = df_lab,
          mapping = ggplot2::aes(x = x, y = y, label = label),
          colour  = "grey30",
          size    = 3,
          hjust   = 0,
          inherit.aes = FALSE,
          show.legend = FALSE
        )
    }
  }

  # ========================================================================
  # 14. Labels
  # ========================================================================
  p <- p +
    ggplot2::labs(
      title = "Incremental Cost-Effectiveness Plane",
      x     = expression(Delta * " Effect"),
      y     = expression(Delta * " Cost")
    )

  return(p)
}
