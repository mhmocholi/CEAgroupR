#' Incremental Cost-Effectiveness (ICER) Plane
#'
#' Produces the Incremental Cost-Effectiveness (CE) plane using bootstrap
#' replicates generated by \code{compute_icers}. The function supports
#' multi-strategy analyses, multiple datasets, subgroup stratification and
#' full user control over aesthetic mappings. All graphical components are
#' constructed on top of the unified internal engine
#' \code{ce_plot_base}, ensuring consistent aesthetics across all plotting
#' functions in the package.
#'
#' The plot includes bootstrap point clouds, optional non-parametric or
#' elliptical contours, mean incremental outcomes for each analysis group,
#' and optional willingness-to-pay (WTP) reference lines.
#'
#' @param data Either the output of \code{compute_icers} or a tibble
#'   produced by \code{combine_icers_results}.
#' @param color_by Variable used for colour mapping. Use \code{"none"} to
#'   disable colour mapping. Defaults to \code{"comparison"} unless
#'   overridden by the user.
#' @param shape_by Variable used to distinguish groups using point shape.
#'   Use \code{"none"} to disable shape mapping. Defaults to \code{"dataset"}
#'   unless overridden.
#' @param facet_by Faceting directive. Options include
#'   \code{"dataset"}, \code{"comparison"},
#'   \code{"subgroup_var"}, \code{"subgroup_level"},
#'   or \code{"subgroup"} to construct a grid of subgroup-variable Ã—
#'   subgroup-level. Use \code{"none"} to disable faceting.
#' @param mode Either \code{"Overall"} or \code{"Subgroups"}, controlling
#'   which subset of results is shown.
#' @param filter_expr Optional tidyverse-style filtering expression applied
#'   before plotting.
#' @param show_points Logical. Display bootstrap clouds.
#' @param show_means Logical. Display mean incremental points.
#' @param show_contours Logical. Add non-parametric or elliptical contour
#'   layers.
#' @param show_lambdas Logical. Display WTP reference lines if
#'   \code{data} originates from \code{compute_icers}.
#' @param label_lambdas Logical. Add labels to WTP lines.
#' @param contour_type Either \code{"non_parametric"} or \code{"ellipse"}.
#' @param contour_level Numeric or numeric vector with probability mass
#'   levels for contour construction (e.g., \code{0.95}).
#' @param facet_scales Passed to ggplot2 faceting functions.
#' @param palette Colour palette name or vector passed to
#'   \code{ce_plot_base}.
#' @param shapes_palette Optional object of class \code{"cea_shapes"}
#'   defining custom shape values for point layers.
#' @param ... Additional graphical parameters passed to point layers.
#'
#' @return A \code{ggplot} object.
#' @rawNamespace export(plot.icers)
plot.icers <- function(
    data,
    color_by      = NULL,
    shape_by      = NULL,
    facet_by      = NULL,
    mode          = "Overall",
    filter_expr   = NULL,
    show_points   = TRUE,
    show_means    = TRUE,
    show_contours = FALSE,
    show_lambdas  = TRUE,
    label_lambdas = FALSE,
    contour_type  = "non_parametric",
    contour_level = 0.95,
    facet_scales  = "fixed",
    palette       = "Dark2",
    shapes_palette = NULL,
    ...
) {

  `%||%` <- function(a, b) if (!is.null(a)) a else b

  # ========================================================================
  # 1. Extract data
  # ========================================================================
  if (inherits(data, "cea_results_list")) {
    df          <- data$combined_replicates
    lambda_vals <- data$settings$lambda
  } else {
    df          <- data
    lambda_vals <- NULL
  }

  if (!"group_uid" %in% names(df)) {
    df$group_uid <- with(
      df,
      paste(dataset, subgroup_var, subgroup_level, comparison, sep = "_")
    )
  }

  # ========================================================================
  # 2. Filtering
  # ========================================================================
  if (!is.null(filter_expr)) {
    df <- dplyr::filter(df, !!rlang::parse_expr(filter_expr))
  }

  # ========================================================================
  # 3. Mode filtering
  # ========================================================================
  mode <- match.arg(mode, c("Overall", "Subgroups"))

  if (mode == "Overall") {
    df <- df[df$subgroup_var == "Overall" | is.na(df$subgroup_var), ]
  } else {
    df <- df[df$subgroup_var != "Overall" & !is.na(df$subgroup_var), ]
  }

  # ========================================================================
  # 4. Default aesthetic mappings
  # ========================================================================
  default_color <- "comparison"
  default_shape <- "dataset"
  default_facet <- if (mode == "Subgroups") "subgroup" else "none"

  resolved_color <- color_by %||% default_color
  resolved_shape <- shape_by %||% default_shape
  resolved_facet <- facet_by %||% default_facet

  if (identical(color_by, "none")) resolved_color <- NULL
  if (identical(shape_by, "none")) resolved_shape <- NULL
  if (identical(facet_by, "none")) resolved_facet <- NULL

  # ========================================================================
  # 5. Base layout via ce_plot_base()
  # ========================================================================
  base <- ce_plot_base(
    data           = df,
    color_by       = resolved_color,
    shape_by       = resolved_shape,
    facet_by       = resolved_facet,
    facet_scales   = facet_scales,
    palette        = palette,
    shapes_palette = shapes_palette
  )

  p             <- base$plot
  color_var     <- base$color_var
  shape_var     <- base$shape_var
  palette_vals  <- base$palette_values
  shape_vals    <- base$shape_values
  linetype_vals <- base$linetype_values

  valid_color <- !is.null(color_var)
  valid_shape <- !is.null(shape_var)

  # ========================================================================
  # 6. Colour scale
  # ========================================================================
  if (valid_color) {

    lvls <- unique(df[[color_var]])
    pal  <- palette_vals

    if (is.null(names(pal))) {
      pal <- rep(pal, length.out = length(lvls))
      names(pal) <- lvls
    }

    color_map <- pal[lvls]
    p <- p + ggplot2::scale_colour_manual(values = color_map)

  } else {
    color_map <- c(fixed = palette_vals[1])
  }

  # ========================================================================
  # 7. Shape scale (points and means only)
  # ========================================================================
  if (valid_shape) {
    if (!is.null(shape_vals)) {
      p <- p + ggplot2::scale_shape_manual(values = shape_vals)
    } else {
      p <- p + ggplot2::scale_shape_discrete()
    }
  }

  # ========================================================================
  # 8. Axes
  # ========================================================================
  p <- p +
    ggplot2::geom_hline(yintercept = 0, colour = "grey70", linetype = "dashed") +
    ggplot2::geom_vline(xintercept = 0, colour = "grey70", linetype = "dashed")

  # ========================================================================
  # 9. Legend cleanup
  # ========================================================================
  if (valid_color &&
      dplyr::n_distinct(df[[color_var]]) == 1) {
    p <- p + ggplot2::guides(colour = "none")
  }

  if (valid_shape &&
      dplyr::n_distinct(df[[shape_var]]) == 1) {
    p <- p + ggplot2::guides(shape = "none")
  }

  # ========================================================================
  # 10. Bootstrap clouds
  # ========================================================================
  if (show_points) {

    usr <- list(...)

    n_rep <- dplyr::n_distinct(df$replicate)
    alpha_auto <- min(0.9, max(0.3, 0.9 - 0.25 * log10(n_rep / 100)))

    alpha_val <- usr$alpha %||% alpha_auto
    size_val  <- usr$size  %||% 1.2

    aes_cloud <- ggplot2::aes(
      x = Delta_Effect,
      y = Delta_Cost
    )
    if (valid_color) aes_cloud$colour <- rlang::sym(color_var)
    if (valid_shape) aes_cloud$shape  <- rlang::sym(shape_var)

    p <- p +
      ggplot2::geom_point(
        data        = df,
        mapping     = aes_cloud,
        alpha       = alpha_val,
        size        = size_val,
        show.legend = TRUE
      )
  }

  # ========================================================================
  # 11. Contours
  # ========================================================================
  if (show_contours) {

    contour_type  <- match.arg(contour_type, c("non_parametric", "ellipse"))
    contour_level <- pmin(pmax(contour_level, 0.001), 0.999)

    for (gid in unique(df$group_uid)) {

      sub <- df[df$group_uid == gid, ]
      if (nrow(sub) < 30) next

      color_key <- if (valid_color) as.character(unique(sub[[color_var]])[1]) else "fixed"
      col_ct    <- colorspace::darken(color_map[[color_key]], 0.55)

      if (valid_shape) {
        shape_key <- as.character(unique(sub[[shape_var]])[1])
        lt_ct     <- linetype_vals[shape_key]
      } else {
        lt_ct <- "solid"
      }

      if (contour_type == "non_parametric") {

        dens <- MASS::kde2d(sub$Delta_Effect, sub$Delta_Cost, n = 200)

        grid <- expand.grid(
          Delta_Effect = dens$x,
          Delta_Cost   = dens$y
        )
        grid$z <- as.vector(dens$z)

        dx <- diff(dens$x)[1]
        dy <- diff(dens$y)[1]

        z_sorted <- sort(grid$z, decreasing = TRUE)
        cum_vol  <- cumsum(z_sorted) * dx * dy

        for (lvl in contour_level) {
          idx <- which(cum_vol >= lvl)[1]
          threshold <- z_sorted[idx]

          p <- p +
            ggplot2::geom_contour(
              data        = grid,
              mapping     = ggplot2::aes(
                x = Delta_Effect,
                y = Delta_Cost,
                z = z
              ),
              breaks      = threshold,
              colour      = col_ct,
              linetype    = lt_ct,
              linewidth   = 0.6,
              inherit.aes = FALSE,
              show.legend = FALSE
            )
        }

      } else {

        mu <- colMeans(sub[, c("Delta_Effect", "Delta_Cost")], na.rm = TRUE)
        cv <- stats::cov(sub[, c("Delta_Effect", "Delta_Cost")], use = "pairwise")
        eg <- eigen(cv)

        for (lvl in contour_level) {

          chi <- sqrt(stats::qchisq(lvl, df = 2))
          t   <- seq(0, 2 * pi, length.out = 200)

          xy <- t(mu + eg$vectors %*%
                    (sqrt(eg$values) * chi *
                       rbind(cos(t), sin(t))))

          p <- p +
            ggplot2::geom_path(
              data = data.frame(
                Delta_Effect = xy[, 1],
                Delta_Cost   = xy[, 2]
              ),
              mapping     = ggplot2::aes(Delta_Effect, Delta_Cost),
              colour      = col_ct,
              linetype    = lt_ct,
              linewidth   = 0.6,
              inherit.aes = FALSE,
              show.legend = FALSE
            )
        }
      }
    }
  }

  # ========================================================================
  # 12. Mean points
  # ========================================================================
  if (show_means) {

    means <- df %>%
      dplyr::group_by(dataset, subgroup_var, subgroup_level,
                      comparison, group_uid) %>%
      dplyr::summarise(
        Delta_Effect = mean(Delta_Effect, na.rm = TRUE),
        Delta_Cost   = mean(Delta_Cost,   na.rm = TRUE),
        colour_key   = if (valid_color) dplyr::first(.data[[color_var]])
        else "fixed",
        shape_key    = if (valid_shape) dplyr::first(.data[[shape_var]])
        else "fixed",
        .groups      = "drop"
      )

    means$fill_col   <- color_map[means$colour_key]
    means$border_col <- colorspace::darken(means$fill_col, 0.55)

    p <- p +
      ggplot2::geom_point(
        data = means,
        mapping = ggplot2::aes(
          x = Delta_Effect,
          y = Delta_Cost,
          shape = shape_key,
          group = group_uid
        ),
        fill        = means$fill_col,
        colour      = means$border_col,
        size        = 2.5,
        stroke      = 1,
        inherit.aes = FALSE,
        show.legend = FALSE
      )
  }

  # ========================================================================
  # 13. WTP lambda lines
  # ========================================================================
  if (show_lambdas && !is.null(lambda_vals)) {

    for (l in lambda_vals) {
      p <- p + ggplot2::geom_abline(
        slope     = l,
        intercept = 0,
        colour    = "grey45",
        linetype  = "dashed",
        linewidth = 0.6
      )
    }

    if (label_lambdas) {

      max_x <- max(df$Delta_Effect, na.rm = TRUE)

      df_lab <- data.frame(
        x     = max_x * 0.85,
        y     = lambda_vals * max_x,
        label = paste0("lambda = ", lambda_vals)
      )

      p <- p +
        ggplot2::geom_text(
          data    = df_lab,
          mapping = ggplot2::aes(x = x, y = y, label = label),
          colour  = "grey30",
          size    = 3,
          hjust   = 0,
          inherit.aes = FALSE,
          show.legend = FALSE
        )
    }
  }

  # ========================================================================
  # 14. Labels
  # ========================================================================
  p <- p +
    ggplot2::labs(
      title = "Incremental Cost-Effectiveness Plane",
      x     = expression(Delta * " Effect"),
      y     = expression(Delta * " Cost")
    )

  return(p)
}
