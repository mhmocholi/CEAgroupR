#' Plot Cost-Effectiveness Acceptability Curves (CEAC)
#'
#' Produces Cost-Effectiveness Acceptability Curves (CEACs) derived from
#' bootstrap replicates generated by \code{compute_icers}. For a given
#' willingness-to-pay (WTP) threshold \eqn{lambda}, the CEAC represents the
#' probability that an alternative strategy is cost-effective relative to the
#' reference strategy. The function supports multiple strategies, datasets,
#' subgroup structures and full aesthetic overrides.
#'
#' The graphical architecture follows the unified internal engine
#' \code{ce_plot_base}, ensuring consistent profiling across all
#' CEAgroupR visualization functions. CEACs are drawn in the
#' lambdaâ€“probability space, with optional horizontal probability reference
#' lines, vertical lambda reference markers, faceting and user-defined colour
#' and line mappings.
#'
#' @inheritParams plot.icers
#' @param lambda_max Maximum WTP threshold displayed on the x-axis. If
#'   \code{NULL}, a heuristic based on the distribution of the ICER
#'   replicates is used.
#' @param lambda_steps Number of lambda evaluation points.
#' @param show_probabilities Numeric vector of probability levels to draw as
#'   horizontal reference lines.
#' @param show_lambdas Logical; if \code{TRUE}, draw vertical reference lines
#'   at the values supplied to \code{lambdas}.
#' @param lambdas Numeric vector of WTP thresholds used as vertical markers.
#' @param return_data Logical; if \code{TRUE}, return the CEAC data table
#'   instead of a plot.
#'
#' @return A \code{ggplot} object or a CEAC data table when
#'   \code{return_data = TRUE}.
#' @rawNamespace export(plot.ceacs)
plot.ceacs <- function(
    data,
    color_by = NULL,
    shape_by = NULL,
    facet_by = NULL,
    mode = "Overall",
    filter_expr = NULL,
    facet_scales = "fixed",
    lambda_max = NULL,
    lambda_steps = 100,
    show_probabilities = NULL,
    show_lambdas = FALSE,
    lambdas = NULL,
    palette = "Dark2",
    shapes_palette = NULL,
    return_data = FALSE,
    ...
) {

  `%||%` <- function(a, b) if (!is.null(a)) a else b

  # ===========================================================================
  # 1. Extract data
  # ===========================================================================
  if (inherits(data, "cea_results_list")) {

    if (is.null(data$combined_replicates))
      stop("'combined_replicates' not found. Run compute_icers() first.")

    df <- data$combined_replicates
    default_lambdas <- data$settings$lambda

  } else if (inherits(data, "data.frame")) {

    df <- data
    default_lambdas <- NULL

  } else stop("Input must be a cea_results_list or a data frame.")

  if (!"group_uid" %in% names(df)) {
    df$group_uid <- with(
      df, paste(dataset, subgroup_var, subgroup_level, comparison, sep = "_")
    )
  }

  # ===========================================================================
  # 2. Filtering
  # ===========================================================================
  if (!is.null(filter_expr)) {
    parsed <- tryCatch(
      rlang::parse_expr(filter_expr),
      error = function(e) stop("Invalid filter_expr.")
    )
    df <- dplyr::filter(df, !!parsed)
  }

  # ===========================================================================
  # 3. Mode filtering
  # ===========================================================================
  mode <- match.arg(mode, c("Overall", "Subgroups"))

  if (mode == "Overall") {
    df <- df[df$subgroup_var == "Overall" | is.na(df$subgroup_var), ]
  } else {
    df <- df[df$subgroup_var != "Overall" & !is.na(df$subgroup_var), ]
  }

  # ===========================================================================
  # 4. Lambda grid
  # ===========================================================================
  if (is.null(lambda_max)) {
    ratio <- df$Delta_Cost / df$Delta_Effect
    ratio <- ratio[is.finite(ratio)]

    lambda_max <- suppressWarnings(
      max(0, stats::quantile(abs(ratio), 0.9, na.rm = TRUE))
    )

    if (!is.finite(lambda_max) || lambda_max <= 0)
      lambda_max <- 100000
  }

  lambda_seq <- seq(0, lambda_max, length.out = lambda_steps)
  if (is.null(lambdas))
    lambdas <- default_lambdas

  # ===========================================================================
  # 5. Compute CEAC curves
  # ===========================================================================
  compute_ceac <- function(sub_df) {
    tibble::tibble(
      lambda = lambda_seq,
      prob   = sapply(
        lambda_seq,
        function(l)
          mean(sub_df$Delta_Cost < l * sub_df$Delta_Effect, na.rm = TRUE)
      )
    )
  }

  ceac_df <- df %>%
    dplyr::group_by(group_uid) %>%
    dplyr::group_modify(~ compute_ceac(.x)) %>%
    dplyr::ungroup() %>%
    dplyr::left_join(
      df %>% dplyr::select(
        group_uid, dataset, subgroup_var, subgroup_level, comparison
      ) %>% dplyr::distinct(),
      by = "group_uid"
    )

  if (return_data)
    return(ceac_df)

  # ===========================================================================
  # 6. Defaults for aesthetics
  # ===========================================================================
  default_color  <- "comparison"
  default_shape  <- "dataset"
  default_facet  <- if (mode == "Subgroups") "subgroup" else "none"

  resolved_color <- color_by %||% default_color
  resolved_shape <- shape_by %||% default_shape
  resolved_facet <- facet_by %||% default_facet

  if (identical(color_by, "none")) resolved_color <- NULL
  if (identical(shape_by,  "none")) resolved_shape <- NULL
  if (identical(facet_by,  "none")) resolved_facet <- NULL

  # ===========================================================================
  # 7. Base layout (ce_plot_base)
  # ===========================================================================
  base <- ce_plot_base(
    data           = ceac_df,
    color_by       = resolved_color,
    shape_by       = resolved_shape,
    facet_by       = resolved_facet,
    facet_scales   = facet_scales,
    palette        = palette,
    shapes_palette = shapes_palette
  )

  color_var        <- base$color_var
  shape_var        <- base$shape_var
  palette_values  <- base$palette_values
  linetype_values <- base$linetype_values
  theme_ceac      <- base$plot$theme
  facet_layer     <- base$plot$facet

  # ===========================================================================
  # 8. Build CEAC plot base
  # ===========================================================================
  p <- ggplot2::ggplot(
    ceac_df,
    ggplot2::aes(x = lambda, y = prob)
  ) +
    theme_ceac

  if (inherits(facet_layer, "ggproto"))
    p <- p + facet_layer

  # ===========================================================================
  # 9. Aesthetic mapping for CEAC lines
  # ===========================================================================
  aes_ceac <- ggplot2::aes(group = group_uid)

  if (!is.null(color_var))
    aes_ceac$colour <- rlang::sym(color_var)

  if (!is.null(shape_var))
    aes_ceac$linetype <- rlang::sym(shape_var)

  # ===========================================================================
  # 10. Scales BEFORE drawing
  # ===========================================================================
  if (!is.null(color_var))
    p <- p + ggplot2::scale_colour_manual(values = palette_values)

  if (!is.null(shape_var)) {
    if (!is.null(linetype_values)) {
      p <- p + ggplot2::scale_linetype_manual(values = linetype_values)
    } else {
      p <- p + ggplot2::scale_linetype_discrete()
    }
  }

  if (!is.null(color_var) &&
      dplyr::n_distinct(ceac_df[[color_var]]) == 1)
    p <- p + ggplot2::guides(colour = "none")

  if (!is.null(shape_var) &&
      dplyr::n_distinct(ceac_df[[shape_var]]) == 1)
    p <- p + ggplot2::guides(linetype = "none")

  # ===========================================================================
  # 11. CEAC lines
  # ===========================================================================
  args  <- list(...)
  lw    <- args$linewidth %||% 1
  alpha <- args$alpha %||% 1

  p <- p +
    ggplot2::geom_line(
      data    = ceac_df,
      mapping = aes_ceac,
      linewidth = lw,
      alpha     = alpha
    )

  # ===========================================================================
  # 12. Probability reference lines
  # ===========================================================================
  if (!is.null(show_probabilities)) {

    probs <- show_probabilities[is.finite(show_probabilities)]

    for (pr in probs) {
      p <- p +
        ggplot2::geom_hline(
          yintercept = pr,
          colour = "grey40",
          linetype = "dashed",
          linewidth = 0.6
        )
    }
  }

  # ===========================================================================
  # 13. Lambda vertical reference lines
  # ===========================================================================
  if (show_lambdas && !is.null(lambdas)) {
    p <- p +
      ggplot2::geom_vline(
        xintercept = lambdas,
        colour = "grey50",
        linetype = "dashed",
        linewidth = 0.6
      )
  }

  # ===========================================================================
  # 14. Axes formatting
  # ===========================================================================
  x_breaks <- pretty(lambda_seq, 5)
  if (show_lambdas && !is.null(lambdas))
    x_breaks <- sort(unique(c(x_breaks, lambdas)))

  y_breaks <- c(0, 0.25, 0.5, 0.75, 1)
  if (!is.null(show_probabilities))
    y_breaks <- sort(unique(c(y_breaks, show_probabilities)))

  p <- p +
    ggplot2::scale_x_continuous(
      breaks = x_breaks,
      labels = scales::label_number(accuracy = 1)
    ) +
    ggplot2::scale_y_continuous(
      limits = c(0, 1),
      breaks = y_breaks,
      labels = scales::label_number(accuracy = 0.01)
    ) +
    ggplot2::labs(
      title = "Cost-Effectiveness Acceptability Curve (CEAC)",
      x     = expression(Willingness * "-to-" * Pay ~ (lambda)),
      y     = "Probability cost-effective"
    )

  return(p)
}
