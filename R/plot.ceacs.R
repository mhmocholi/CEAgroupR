#' Plot Cost-Effectiveness Acceptability Curves (CEAC)
#'
#' Produces Cost-Effectiveness Acceptability Curves (CEACs) derived from
#' bootstrap replicates generated by compute_icers(). CEACs represent, for each
#' value of the willingness-to-pay threshold (lambda), the probability that an
#' alternative strategy is cost-effective relative to the reference.
#'
#' The function follows the unified graphical architecture of plot.icers(),
#' adapted to the CEAC geometry (lambdaâ€“probability space). It supports
#' conditional reference lines for both probabilities (horizontal) and lambda
#' thresholds (vertical), faceting, and full aesthetic overrides.
#'
#' @inheritParams plot.icers
#' @param lambda_max Maximum lambda displayed on the x-axis.
#' @param lambda_steps Number of lambda evaluation points.
#' @param show_probabilities Numeric vector of probability levels to show as
#'        horizontal reference lines and y-axis tick marks.
#' @param show_lambdas Logical; draw vertical reference lines at lambda values.
#' @param lambdas Numeric vector of lambda reference markers.
#' @param return_data Logical; return CEAC table instead of plot.
#'
#' @return A ggplot object or a CEAC data table (if return_data = TRUE).
#' @export
plot.ceacs <- function(
    data,
    color_by = NULL,
    shape_by = NULL,
    facet_by = NULL,
    mode = "Overall",
    filter_expr = NULL,
    facet_scales = "fixed",
    lambda_max = NULL,
    lambda_steps = 100,
    show_probabilities = NULL,
    show_lambdas = FALSE,
    lambdas = NULL,
    palette = NULL,
    return_data = FALSE,
    ...
) {

  `%||%` <- function(a,b) if (!is.null(a)) a else b

  # ===========================================================================
  # 1. Extract data
  # ===========================================================================
  if (inherits(data, "cea_results_list")) {

    if (is.null(data$combined_replicates))
      stop("'combined_replicates' not found; run compute_icers().")

    df <- data$combined_replicates
    default_lambdas <- data$settings$lambda

  } else if (inherits(data, "data.frame")) {

    df <- data
    default_lambdas <- NULL

  } else stop("Input must be a cea_results_list or a data frame.")

  if (!"group_uid" %in% names(df)) {
    df$group_uid <- with(
      df, paste(dataset, subgroup_var, subgroup_level, comparison, sep="_")
    )
  }

  # ===========================================================================
  # 2. Filtering
  # ===========================================================================
  if (!is.null(filter_expr)) {
    parsed <- tryCatch(rlang::parse_expr(filter_expr),
                       error=function(e) stop("Invalid filter_expr."))
    df <- dplyr::filter(df, !!parsed)
  }

  # ===========================================================================
  # 3. Mode filtering
  # ===========================================================================
  mode <- match.arg(mode, c("Overall","Subgroups"))

  if (mode=="Overall") {
    df <- df[df$subgroup_var=="Overall" | is.na(df$subgroup_var), ]
  } else {
    df <- df[df$subgroup_var!="Overall" & !is.na(df$subgroup_var), ]
  }

  # ===========================================================================
  # 4. Lambda grid
  # ===========================================================================
  if (is.null(lambda_max)) {
    ratio <- df$Delta_Cost / df$Delta_Effect
    ratio <- ratio[is.finite(ratio)]
    lambda_max <- suppressWarnings(
      max(0, quantile(abs(ratio), 0.9, na.rm=TRUE))
    )
    if (!is.finite(lambda_max) || lambda_max <= 0)
      lambda_max <- 100000
  }

  lambda_seq <- seq(0, lambda_max, length.out=lambda_steps)
  if (is.null(lambdas))
    lambdas <- default_lambdas

  # ===========================================================================
  # 5. Compute CEAC curves
  # ===========================================================================
  compute_ceac <- function(sub_df) {
    tibble::tibble(
      lambda=lambda_seq,
      prob=sapply(lambda_seq, function(l)
        mean(sub_df$Delta_Cost < l * sub_df$Delta_Effect, na.rm=TRUE))
    )
  }

  ceac_df <- df %>%
    dplyr::group_by(group_uid) %>%
    dplyr::group_modify(~ compute_ceac(.x)) %>%
    dplyr::ungroup() %>%
    dplyr::left_join(
      df %>% dplyr::select(
        group_uid, dataset, subgroup_var, subgroup_level, comparison
      ) %>% dplyr::distinct(),
      by="group_uid"
    )

  if (return_data)
    return(ceac_df)

  # ===========================================================================
  # 6. Defaults
  # ===========================================================================
  default_color  <- "comparison"
  default_shape  <- "dataset"
  default_facet  <- if (mode=="Subgroups") "subgroup" else "none"

  resolved_color <- color_by %||% default_color
  resolved_shape <- shape_by %||% default_shape
  resolved_facet <- facet_by %||% default_facet

  if (identical(color_by,"none"))  resolved_color <- NULL
  if (identical(shape_by,"none"))  resolved_shape <- NULL
  if (identical(facet_by,"none"))  resolved_facet <- NULL

  # ===========================================================================
  # 7. ce_plot_base (aesthetics and facet)
  # ===========================================================================
  base <- ce_plot_base(
    data         = ceac_df,
    color_by     = resolved_color,
    shape_by     = resolved_shape,
    facet_by     = resolved_facet,
    facet_scales = facet_scales,
    palette      = palette,
    auto_layout  = TRUE
  )

  color_var      <- base$color_var
  shape_var      <- base$shape_var
  palette_values <- base$palette_values
  theme_ceac     <- base$plot$theme
  facet_layer    <- base$plot$facet

  # ===========================================================================
  # 8. Build CEAC plot base
  # ===========================================================================
  p <- ggplot2::ggplot(
    ceac_df,
    ggplot2::aes(x=lambda, y=prob)
  ) + theme_ceac

  if (inherits(facet_layer,"ggproto"))
    p <- p + facet_layer

  # ===========================================================================
  # 9. CEAC aesthetics
  # ===========================================================================
  aes_ceac <- ggplot2::aes(group=group_uid)

  if (!is.null(color_var))
    aes_ceac$colour <- rlang::sym(color_var)

  if (!is.null(shape_var))
    aes_ceac$linetype <- rlang::sym(shape_var)

  # ===========================================================================
  # 10. Scales BEFORE drawing
  # ===========================================================================
  if (!is.null(color_var))
    p <- p + ggplot2::scale_colour_manual(values=palette_values)

  if (!is.null(shape_var))
    p <- p + ggplot2::scale_linetype_discrete()

  if (!is.null(color_var) &&
      dplyr::n_distinct(ceac_df[[color_var]])==1)
    p <- p + ggplot2::guides(colour="none")

  if (!is.null(shape_var) &&
      dplyr::n_distinct(ceac_df[[shape_var]])==1)
    p <- p + ggplot2::guides(linetype="none")

  # ===========================================================================
  # 11. Draw CEAC curves (always)
  # ===========================================================================
  args  <- list(...)
  lw    <- args$linewidth %||% 1
  alpha <- args$alpha %||% 1

  p <- p +
    ggplot2::geom_line(
      data = ceac_df,
      mapping = aes_ceac,
      linewidth = lw,
      alpha = alpha
    )

  # ===========================================================================
  # 12. Probability reference lines
  # ===========================================================================
  if (!is.null(show_probabilities)) {

    probs <- show_probabilities[is.finite(show_probabilities)]

    for (pr in probs) {
      p <- p +
        ggplot2::geom_hline(
          yintercept = pr,
          colour="grey40",
          linetype="dashed",
          linewidth=0.6
        )
    }
  }

  # ===========================================================================
  # 13. Lambda reference lines
  # ===========================================================================
  if (show_lambdas && !is.null(lambdas)) {
    p <- p +
      ggplot2::geom_vline(
        xintercept = lambdas,
        colour="grey50",
        linetype="dashed",
        linewidth=0.6
      )
  }

  # ===========================================================================
  # 14. Axis formatting
  # ===========================================================================
  x_breaks <- pretty(lambda_seq, 5)
  if (show_lambdas && !is.null(lambdas))
    x_breaks <- sort(unique(c(x_breaks, lambdas)))

  y_breaks <- c(0, 0.25, 0.5, 0.75, 1)
  if (!is.null(show_probabilities))
    y_breaks <- sort(unique(c(y_breaks, show_probabilities)))

  p <- p +
    ggplot2::scale_x_continuous(
      breaks = x_breaks,
      labels = scales::label_number(accuracy=1)
    ) +
    ggplot2::scale_y_continuous(
      limits=c(0,1),
      breaks=y_breaks,
      labels=scales::label_number(accuracy=0.01)
    ) +
    ggplot2::labs(
      title="Cost-Effectiveness Acceptability Curve (CEAC)",
      x=expression(Willingness * "-to-" * Pay ~ (lambda)),
      y="Probability cost-effective"
    )

  return(p)
}
