#' Combine Bootstrap Replicates from Cost-Effectiveness Analyses
#'
#' Utility function that aggregates bootstrap replicates generated by
#' \code{\link{compute_icers}} into a single tidy data frame suitable for
#' downstream visualization and post-processing. This function provides the
#' standardized data structure consumed by all graphical functions in
#' CEAgroupR.
#'
#' The function supports results obtained from single- or multi-dataset
#' analyses, including explicit subgroup-level results. When multiple datasets
#' (e.g. base case and alternative scenarios) are present, bootstrap replicates
#' are combined across datasets while preserving dataset identity and full
#' analytical traceability.
#'
#' Subgroup variables and subgroup levels are normalized as factors to ensure
#' consistent behaviour in faceting, grouping and aesthetic mappings.
#'
#' @param ... One or more objects returned by \code{\link{compute_icers}},
#'   including objects of class \code{cea_results} or
#'   \code{cea_results_list}. If a single \code{cea_results_list} object is
#'   supplied, its elements are automatically expanded.
#'
#' @details
#' In typical workflows, users do not need to call this function explicitly,
#' as it is invoked internally by \code{compute_icers}. It is exposed primarily
#' to support advanced use cases, custom post-processing, or integration with
#' external visualization and reporting tools.
#'
#' @return
#' A tibble containing bootstrap replicates with one row per replicate and
#' comparison, and the following key columns:
#' \itemize{
#'   \item \code{dataset}: Dataset or scenario identifier.
#'   \item \code{subgroup_var}: Subgroup variable name ("Overall" if none).
#'   \item \code{subgroup_level}: Subgroup level as a factor ("Overall" if none).
#'   \item \code{comparison}: Strategy comparison.
#'   \item \code{group_uid}: Hierarchical identifier combining dataset,
#'         subgroup and comparison.
#'   \item \code{replicate}: Bootstrap draw index.
#'   \item Incremental and absolute outcome measures such as
#'         \code{Delta_Cost}, \code{Delta_Effect}, \code{ICER},
#'         and \code{NMB_*} columns.
#' }
#'
#' @examples
#' ## Example 1: Extract combined bootstrap replicates from a CEA analysis
#' res <- compute_icers(
#'   data      = cua_base,
#'   group     = "group",
#'   cost      = "cost_total",
#'   effect    = "effect",
#'   ref_group = "g0",
#'   R         = 50,
#'   seed      = 123
#' )
#'
#' boot_df <- combine_icers_results(res)
#' head(boot_df)
#'
#' ## Example 2: Multi-dataset analysis (base case and discounted scenario)
#' data_list <- list(
#'   base_case        = cua_multi,
#'   discounted_case = cua_multi_discounted
#' )
#'
#' res_multi <- compute_icers(
#'   data      = data_list,
#'   group     = "group",
#'   cost      = "cost_total",
#'   effect    = "effect",
#'   ref_group = "usual_care",
#'   R         = 50,
#'   seed      = 123
#' )
#'
#' boot_multi <- combine_icers_results(res_multi)
#' dplyr::count(boot_multi, dataset)
#'
#' @export

combine_icers_results <- function(...) {

  objects <- list(...)
  n_objs <- length(objects)
  if (n_objs == 0) stop("At least one object must be provided.")

  # ---------------------------------------------------------------
  # 0. Unpack cea_results_list if necessary
  # ---------------------------------------------------------------
  if (n_objs == 1 && inherits(objects[[1]], "cea_results_list")) {
    objects <- objects[[1]]
    n_objs <- length(objects)
  }

  # Keep only objects that look like cea_results
  objects <- Filter(function(x)
    is.list(x) && ("Overall" %in% names(x) || "Subgroups" %in% names(x)),
    objects)

  if (length(objects) == 0)
    stop("No valid 'cea_results' objects found for combination.")

  # ---------------------------------------------------------------
  # 1. Helper: extract bootstrap samples from a single cea_results
  # ---------------------------------------------------------------
  extract_bootstrap <- function(res_obj, dataset_name) {

    # ---- Helper to extract from a cea_base ----
    extract_one <- function(x, subgroup_var = NA, subgroup_level = NA, comparison = NA) {

      if (is.null(x$bootstrap_samples)) return(NULL)
      df <- x$bootstrap_samples
      if (nrow(df) == 0) return(NULL)

      df$replicate     <- seq_len(nrow(df))
      df$dataset       <- dataset_name

      # Normalize subgroup_var
      df$subgroup_var   <- ifelse(is.na(subgroup_var), "Overall", subgroup_var)

      # Normalize subgroup_level (always factor)
      if (is.na(subgroup_level)) {
        df$subgroup_level <- factor("Overall")
      } else {
        # Keep factor ordering if supplied
        if (is.factor(subgroup_level)) {
          df$subgroup_level <- subgroup_level
        } else if (is.numeric(subgroup_level) || is.integer(subgroup_level)) {
          df$subgroup_level <- factor(
            as.character(subgroup_level),
            levels = sort(unique(as.character(subgroup_level))),
            ordered = TRUE
          )
        } else {
          df$subgroup_level <- factor(
            as.character(subgroup_level),
            levels = unique(as.character(subgroup_level)),
            ordered = FALSE
          )
        }
      }

      # Normalize comparison
      df$comparison <- ifelse(is.na(comparison), "single_comparison", comparison)

      df
    }

    # ---- Extract Overall ----
    overall_df <- NULL
    if (!is.null(res_obj$Overall)) {

      if (inherits(res_obj$Overall, "cea_base")) {
        overall_df <- extract_one(res_obj$Overall)
      }

      if (inherits(res_obj$Overall, "cea_multicomparison")) {
        overall_df <- dplyr::bind_rows(lapply(names(res_obj$Overall), function(cmp) {
          obj <- res_obj$Overall[[cmp]]
          extract_one(obj, comparison = obj$comparison)
        }))
      }
    }

    # ---- Extract Subgroups ----
    sub_df <- NULL
    if (!is.null(res_obj$Subgroups) && length(res_obj$Subgroups) > 0) {

      sub_df <- dplyr::bind_rows(lapply(names(res_obj$Subgroups), function(var) {

        dplyr::bind_rows(lapply(names(res_obj$Subgroups[[var]]), function(lvl) {

          obj <- res_obj$Subgroups[[var]][[lvl]]

          if (inherits(obj, "cea_base")) {
            extract_one(obj,
                        subgroup_var   = var,
                        subgroup_level = lvl)
          }

          if (inherits(obj, "cea_multicomparison")) {
            dplyr::bind_rows(lapply(names(obj), function(cmp) {
              x <- obj[[cmp]]
              extract_one(x,
                          subgroup_var   = var,
                          subgroup_level = lvl,
                          comparison     = x$comparison)
            }))
          }
        }))
      }))
    }

    dplyr::bind_rows(overall_df, sub_df)
  }

  # ---------------------------------------------------------------
  # 2. Extract all bootstrap replicates from all datasets
  # ---------------------------------------------------------------
  combined_list <- lapply(names(objects), function(nm) {
    extract_bootstrap(objects[[nm]], dataset_name = nm)
  })

  combined_df <- dplyr::bind_rows(combined_list)

  if (nrow(combined_df) == 0)
    stop("No bootstrap samples found in the supplied objects.")

  # ---------------------------------------------------------------
  # 3. Build hierarchical unique identifier
  # ---------------------------------------------------------------
  combined_df$group_uid <- with(
    combined_df,
    paste(dataset, subgroup_var, subgroup_level, comparison, sep = "_")
  )

  # ---------------------------------------------------------------
  # 4. Ensure subgroup_var and subgroup_level are factors
  # ---------------------------------------------------------------
  combined_df$subgroup_var <- factor(combined_df$subgroup_var,
                                     levels = unique(combined_df$subgroup_var))

  # subgroup_level is already factor when created in extract_one(),
  # but enforce proper factor class to be safe:
  if (!is.factor(combined_df$subgroup_level)) {
    combined_df$subgroup_level <- factor(as.character(combined_df$subgroup_level))
  }

  # ---------------------------------------------------------------
  # 5. Order columns
  # ---------------------------------------------------------------
  stat_cols <- grep("^(Delta|Mean|ICER|NMB_)", names(combined_df), value = TRUE)

  col_order <- c(
    "dataset", "subgroup_var", "subgroup_level", "comparison",
    "group_uid", "replicate",
    stat_cols
  )

  combined_df <- combined_df[, intersect(col_order, names(combined_df))]

  tibble::as_tibble(combined_df)
}
