#' Plot Expected Value of Perfect Information (EVPI)
#'
#' Produces EVPI curves over a sequence of willingness-to-pay (λ) values
#' using bootstrap replicates stored in a \code{cea_results_list} object
#' generated by \code{compute_icers()}. The function uses a graphical
#' architecture consistent with other plotting functions in the package,
#' including harmonised aesthetics, palette handling, faceting rules, and
#' support for tidy-style filtering. User-specified aesthetics override defaults.
#'
#' @inheritParams plot.icers
#'
#' @param lambda_max Optional maximum λ on the x-axis. If \code{NULL},
#'   a heuristic based on \eqn{|ΔCost/ΔEffect|} is used.
#' @param lambda_steps Number of λ values used to compute EVPI.
#'
#' @param return_data Logical; if \code{TRUE}, the function returns the EVPI
#'   data table instead of a plot.
#'
#' @return A \code{ggplot} object or a tibble containing EVPI values.
#' @export
plot.evpis <- function(data,
                       color_by    = NULL,
                       shape_by    = NULL,
                       facet_by    = NULL,
                       mode        = "Overall",
                       filter_expr = NULL,
                       facet_scales = "fixed",
                       lambda_max   = NULL,
                       lambda_steps = 100,
                       palette      = NULL,
                       return_data  = FALSE,
                       ...) {

  `%||%` <- function(a, b) if (!is.null(a)) a else b

  # ============================================================
  # 1. Input extraction
  # ============================================================
  if (inherits(data, "cea_results_list")) {

    if (is.null(data$combined_replicates))
      stop("'combined_replicates' missing. Run compute_icers().")

    df <- data$combined_replicates

  } else if (inherits(data, "data.frame")) {

    df <- data

  } else {
    stop("Input must be a cea_results_list or a data frame.")
  }

  if (!"group_uid" %in% names(df)) {
    df$group_uid <- with(
      df, paste(dataset, subgroup_var, subgroup_level, comparison, sep = "_")
    )
  }

  # ============================================================
  # 2. Filtering
  # ============================================================
  if (!is.null(filter_expr)) {
    expr <- rlang::parse_expr(filter_expr)
    df <- dplyr::filter(df, !!expr)
  }

  # ============================================================
  # 3. Mode filtering
  # ============================================================
  mode <- match.arg(mode, c("Overall", "Subgroups"))

  if (mode == "Overall") {
    df <- df[df$subgroup_var == "Overall" | is.na(df$subgroup_var), ]
  } else {
    df <- df[df$subgroup_var != "Overall" & !is.na(df$subgroup_var), ]
  }

  # ============================================================
  # 4. Compute lambda grid
  # ============================================================
  if (is.null(lambda_max)) {
    ratio <- df$Delta_Cost / df$Delta_Effect
    ratio <- ratio[is.finite(ratio)]
    lambda_max <- max(0, suppressWarnings(quantile(abs(ratio), 0.9, na.rm = TRUE)))
    if (!is.finite(lambda_max) || lambda_max <= 0)
      lambda_max <- 100000
  }

  lambda_seq <- seq(0, lambda_max, length.out = lambda_steps)

  # ============================================================
  # 5. EVPI computation
  # ============================================================
  compute_evpi_group <- function(sub_df) {

    dplyr::bind_rows(lapply(lambda_seq, function(l) {

      nmb <- l * sub_df$Delta_Effect - sub_df$Delta_Cost

      perfect <- mean(pmax(0, nmb), na.rm = TRUE)
      current <- max(0, mean(nmb, na.rm = TRUE))

      tibble::tibble(lambda = l, EVPI = perfect - current)
    }))
  }

  evpi_df <- df %>%
    dplyr::group_by(group_uid) %>%
    dplyr::group_modify(~ compute_evpi_group(.x)) %>%
    dplyr::ungroup() %>%
    dplyr::left_join(
      df %>% dplyr::distinct(group_uid, dataset, subgroup_var, subgroup_level, comparison),
      by = "group_uid"
    )

  if (return_data)
    return(evpi_df)

  # ============================================================
  # 6. Default aesthetic behaviour (user override respected)
  # ============================================================
  default_color <- "comparison"
  default_shape <- "dataset"
  default_facet <- if (mode == "Subgroups") "subgroup" else "none"

  resolved_color <- color_by %||% default_color
  resolved_shape <- shape_by %||% default_shape
  resolved_facet <- facet_by %||% default_facet

  if (identical(color_by, "none"))  resolved_color <- NULL
  if (identical(shape_by, "none"))  resolved_shape <- NULL
  if (identical(facet_by, "none"))  resolved_facet <- NULL

  # ============================================================
  # 7. Base plot
  # ============================================================
  base <- ce_plot_base(
    data         = evpi_df,
    color_by     = resolved_color,
    shape_by     = resolved_shape,
    facet_by     = resolved_facet,
    facet_scales = facet_scales,
    palette      = palette,
    auto_layout  = TRUE
  )

  p <- base$plot
  color_var      <- base$color_var
  shape_var      <- base$shape_var
  palette_values <- base$palette_values

  args      <- list(...)
  lw_val    <- args$linewidth %||% 1
  alpha_val <- args$alpha     %||% 1

  # ============================================================
  # 8. Scales before drawing
  # ============================================================
  if (!is.null(color_var))
    p <- p + ggplot2::scale_colour_manual(values = palette_values)

  if (!is.null(shape_var))
    p <- p + ggplot2::scale_linetype_discrete()

  # ============================================================
  # 9. Hide legends with only one level
  # ============================================================
  if (!is.null(color_var) &&
      dplyr::n_distinct(evpi_df[[color_var]]) == 1)
    p <- p + ggplot2::guides(colour = "none")

  if (!is.null(shape_var) &&
      dplyr::n_distinct(evpi_df[[shape_var]]) == 1)
    p <- p + ggplot2::guides(linetype = "none")

  # ============================================================
  # 10. Invisible layer to activate mapping
  # ============================================================
  aes_act <- ggplot2::aes(x = lambda, y = EVPI)

  if (!is.null(color_var))
    aes_act$colour <- rlang::sym(color_var)

  if (!is.null(shape_var))
    aes_act$linetype <- rlang::sym(shape_var)

  p <- p + ggplot2::geom_point(
    data = evpi_df,
    mapping = aes_act,
    alpha = 0,
    inherit.aes = FALSE
  )

  # ============================================================
  # 11. EVPI curve layer
  # ============================================================
  aes_evpi <- ggplot2::aes(
    x = lambda,
    y = EVPI,
    group = group_uid
  )

  if (!is.null(color_var))
    aes_evpi$colour <- rlang::sym(color_var)

  if (!is.null(shape_var))
    aes_evpi$linetype <- rlang::sym(shape_var)

  p <- p +
    ggplot2::geom_line(
      data = evpi_df,
      mapping = aes_evpi,
      linewidth = lw_val,
      alpha     = alpha_val
    )

  # ============================================================
  # 12. Axes and labels
  # ============================================================
  x_breaks <- pretty(lambda_seq, 5)

  p <- p +
    ggplot2::scale_x_continuous(
      breaks = x_breaks,
      labels = scales::label_number()
    ) +
    ggplot2::scale_y_continuous(
      expand = c(0, 0),
      labels = scales::label_number()
    ) +
    ggplot2::labs(
      title = "Expected Value of Perfect Information (EVPI)",
      x     = expression(Willingness * "-to-" * Pay ~ (lambda)),
      y     = "EVPI"
    )

  return(p)
}
