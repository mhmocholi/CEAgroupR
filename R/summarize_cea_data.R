#' Summarize Descriptive Statistics for Cost-Effectiveness Analyses
#'
#' Produces descriptive (non-bootstrap) summary statistics for cost-effectiveness
#' analyses by strategy comparison. This function computes sample sizes, mean
#' and standard deviation of costs and effectiveness, incremental values
#' (delta cost and delta effect), Incremental Cost-Effectiveness Ratios (ICERs),
#' and Net Monetary Benefits (NMBs) for one reference strategy contrasted with
#' alternative strategies.
#'
#' Unlike \code{\link{compute_icers}}, this function does not rely on resampling
#' or uncertainty analysis. It is intended for descriptive reporting, baseline
#' summaries, and tabular outputs commonly required in health economic
#' evaluations and policy analyses.
#'
#' The function supports:
#' \itemize{
#'   \item single or multiple datasets representing alternative analytical
#'         scenarios (e.g. base case, discounted analyses),
#'   \item explicit subgroup analyses treated independently from the overall
#'         population,
#'   \item consistent summarization across strategies, subgroups and scenarios.
#' }
#'
#' When subgroup variables are provided, summaries are computed separately for
#' each subgroup level in addition to the overall population. Subgroup levels
#' are automatically normalized as factors to ensure consistent ordering and
#' downstream processing.
#'
#' @param data A data frame or a named list of data frames containing individual-level
#'   cost and effectiveness outcomes. When a list is supplied, each element is
#'   treated as a separate dataset representing a distinct analytical scenario.
#'
#' @param group Character string specifying the variable that identifies the
#'   intervention or strategy group.
#'
#' @param cost Character string specifying the cost variable.
#'
#' @param effect Character string specifying the effectiveness variable
#'   (e.g. QALYs or other health outcomes).
#'
#' @param subgroup_vars Optional character vector specifying one or more subgroup
#'   variables. When provided, summaries are computed independently for each
#'   subgroup level in addition to the overall population.
#'
#' @param lambda Numeric vector of willingness-to-pay thresholds used to compute
#'   Net Monetary Benefits (NMBs).
#'
#' @param ref_group Character string identifying the reference strategy.
#'
#' @param alt_groups Optional character vector defining which alternative
#'   strategies should be contrasted with the reference. If \code{NULL}, all
#'   non-reference strategies observed in the data are used.
#'
#' @details
#' The returned tibble is designed to support descriptive tables and reporting,
#' and is complementary to the bootstrap-based outputs generated by
#' \code{\link{compute_icers}}. It can be used directly for tabular summaries
#' or as input to custom reporting workflows.
#'
#' @return
#' A tidy tibble containing descriptive summaries for each dataset, subgroup and
#' strategy comparison, including:
#' \itemize{
#'   \item dataset identifiers and subgroup metadata,
#'   \item sample sizes per strategy,
#'   \item mean and standard deviation of costs and effectiveness,
#'   \item incremental outcomes (delta cost, delta effect),
#'   \item ICERs and NMBs at specified willingness-to-pay thresholds.
#' }
#'
#' @examples
#' ## Example 1: Descriptive summary for a single dataset
#' summary_base <- summarize_cea_data(
#'   data      = cua_base,
#'   group     = "group",
#'   cost      = "cost_total",
#'   effect    = "effect",
#'   ref_group = "g0",
#'   lambda    = c(20000, 30000)
#' )
#'
#' head(summary_base)
#'
#' ## Example 2: Multi-dataset summary with subgroup stratification
#' data_list <- list(
#'   base_case        = cua_multi,
#'   discounted_case = cua_multi_discounted
#' )
#'
#' summary_multi <- summarize_cea_data(
#'   data          = data_list,
#'   group         = "group",
#'   cost          = "cost_total",
#'   effect        = "effect",
#'   subgroup_vars = c("diabetes", "HTA"),
#'   ref_group     = "usual_care",
#'   lambda        = c(20000)
#' )
#'
#' dplyr::count(summary_multi, dataset)
#'
#' @importFrom stats sd
#' @export

summarize_cea_data <- function(data, group, cost, effect,
                               subgroup_vars = NULL, lambda = 25000,
                               ref_group = NULL, alt_groups = NULL) {

  # -------------------------------------------------------------------
  # 1. Helper: compute summary for one comparison
  # -------------------------------------------------------------------
  compute_summary <- function(df_sub, dataset, subgroup_var, subgroup_level,
                              ref_group, alt_group) {

    # ---- Normalize subgroup_level to factor ----
    if (is.numeric(subgroup_level) || is.integer(subgroup_level)) {

      subgroup_level <- factor(
        subgroup_level,
        levels  = sort(unique(subgroup_level)),
        ordered = TRUE
      )

    } else {

      subgroup_level <- factor(
        as.character(subgroup_level),
        levels = unique(as.character(subgroup_level)),
        ordered = FALSE
      )
    }

    # ---- Standard comparison logic ----
    df_sub[[group]] <- as.factor(df_sub[[group]])
    df_sub <- df_sub[df_sub[[group]] %in% c(ref_group, alt_group), , drop = FALSE]
    df_sub[[group]] <- factor(df_sub[[group]], levels = c(ref_group, alt_group))

    if (length(unique(df_sub[[group]])) < 2)
      return(NULL)

    n_ref <- sum(df_sub[[group]] == ref_group)
    n_alt <- sum(df_sub[[group]] == alt_group)
    if (n_alt == 0) return(NULL)

    m_cost <- tapply(df_sub[[cost]],   df_sub[[group]], mean, na.rm = TRUE)
    sd_cost <- tapply(df_sub[[cost]],  df_sub[[group]], sd,   na.rm = TRUE)
    m_eff  <- tapply(df_sub[[effect]], df_sub[[group]], mean, na.rm = TRUE)
    sd_eff <- tapply(df_sub[[effect]], df_sub[[group]], sd,   na.rm = TRUE)

    delta_cost <- m_cost[2] - m_cost[1]
    delta_eff  <- m_eff[2]  - m_eff[1]
    icer <- ifelse(delta_eff == 0, NA, delta_cost / delta_eff)

    nmb_vals <- sapply(lambda, function(l)
      l * delta_eff - delta_cost
    )
    names(nmb_vals) <- paste0("NMB_", lambda)

    tibble::tibble(
      dataset        = dataset,
      subgroup_var   = subgroup_var,
      subgroup_level = subgroup_level,
      comparison     = alt_group,
      n_ref = n_ref,
      n_alt = n_alt,
      mean_cost_ref = as.numeric(m_cost[1]),
      sd_cost_ref   = as.numeric(sd_cost[1]),
      mean_cost_alt = as.numeric(m_cost[2]),
      sd_cost_alt   = as.numeric(sd_cost[2]),
      mean_eff_ref  = as.numeric(m_eff[1]),
      sd_eff_ref    = as.numeric(sd_eff[1]),
      mean_eff_alt  = as.numeric(m_eff[2]),
      sd_eff_alt    = as.numeric(sd_eff[2]),
      delta_cost    = as.numeric(delta_cost),
      delta_effect  = as.numeric(delta_eff),
      ICER          = as.numeric(icer),
      !!!as.list(nmb_vals)
    )
  }

  # -------------------------------------------------------------------
  # 2. Helper: summarize a dataset (Overall + Subgroups)
  # -------------------------------------------------------------------
  summarize_one <- function(df, dataset_name) {

    df[[group]] <- as.factor(df[[group]])
    levels_g <- levels(df[[group]])

    if (is.null(ref_group)) ref_group <- levels_g[1]
    if (!ref_group %in% levels_g)
      stop("Reference group not found in dataset ", dataset_name)

    alts <- if (is.null(alt_groups)) setdiff(levels_g, ref_group)
    else intersect(levels_g, alt_groups)

    # ---- Overall summary ----
    overall <- dplyr::bind_rows(lapply(alts, function(alt)
      compute_summary(df, dataset_name,
                      subgroup_var = "Overall",
                      subgroup_level = "Overall",
                      ref_group, alt)
    ))

    # ---- Subgroup summaries ----
    subgroup_part <- NULL

    if (!is.null(subgroup_vars)) {

      subgroup_part <- dplyr::bind_rows(lapply(subgroup_vars, function(v) {

        lvls <- unique(df[[v]])

        dplyr::bind_rows(lapply(lvls, function(lvl) {

          # Normalize subgroup level to factor
          subgroup_level_factor <-
            if (is.numeric(lvl) || is.integer(lvl)) {
              factor(lvl,
                     levels  = sort(lvls),
                     ordered = TRUE)
            } else {
              factor(as.character(lvl),
                     levels = unique(as.character(lvls)))
            }

          dplyr::bind_rows(lapply(alts, function(alt)

            compute_summary(
              df[df[[v]] == lvl, , drop = FALSE],
              dataset_name,
              subgroup_var   = v,
              subgroup_level = subgroup_level_factor,
              ref_group,
              alt
            )
          ))
        }))
      }))
    }

    dplyr::bind_rows(overall, subgroup_part)
  }

  # -------------------------------------------------------------------
  # 3. Single dataset or list
  # -------------------------------------------------------------------
  if (is.data.frame(data)) {

    summarize_one(data, "single_dataset")

  } else {

    dplyr::bind_rows(lapply(names(data), function(dn)
      summarize_one(data[[dn]], dn)
    ))
  }
}
