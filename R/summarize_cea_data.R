#' Summarize descriptive statistics for cost-effectiveness analysis (CEA) datasets
#'
#' Generates descriptive summaries of the datasets used in a cost-effectiveness
#' or cost-utility analysis. The function provides counts, means, and standard
#' deviations for each comparison group and (optionally) for each subgroup
#' defined by the user. It also computes incremental statistics
#' (ΔCost, ΔEffect, ICER, and Net Monetary Benefit (NMB)) for one or more
#' willingness-to-pay thresholds (`lambda`).
#'
#' This function operates at the data level (not bootstrap level) and is designed
#' as part of the integration layer of the \pkg{CEAgroupR} package. It produces
#' a clean, tidy summary table that connects the analytical outputs generated by
#' \code{\link{compute_icers}} with the graphical layer.
#'
#' @section Function role:
#' \code{summarize_cea_data()} replaces the functionality previously implemented
#' in `summary.cea_results()`, which is now deprecated. The current function
#' provides a unified and scalable approach that supports multiple datasets,
#' subgroup analyses, and flexible `lambda` specifications.
#'
#' @param data A data frame or a named list of data frames containing the
#'   variables required for analysis. When a list is supplied, each element is
#'   treated as a separate analytical dataset or scenario.
#' @param group Character. Column name defining the comparison groups (typically
#'   a binary variable such as "control" vs. "intervention").
#' @param cost Character. Column name for total cost.
#' @param effect Character. Column name for the effectiveness measure
#'   (e.g., QALYs or life-years).
#' @param subgroup_vars Optional character vector. Names of subgroup variables
#'   to stratify the analysis. If `NULL`, only overall results are produced.
#' @param lambda Numeric or numeric vector. Willingness-to-pay threshold(s)
#'   used to compute NMB. Defaults to 25000.
#'
#' @return A tibble summarizing descriptive statistics for all datasets and
#'   subgroup levels. Each row represents one overall or subgroup summary, with
#'   the following variables:
#'   \itemize{
#'     \item \code{dataset}: dataset name (or "single_dataset" if only one provided)
#'     \item \code{subgroup_var}: name of the subgroup variable (or "Overall")
#'     \item \code{subgroup_level}: level of the subgroup (or \code{NA} for Overall)
#'     \item \code{n_g0}, \code{n_g1}: sample sizes per comparison group
#'     \item \code{mean_cost_g0}, \code{mean_cost_g1}: mean total costs per group
#'     \item \code{mean_eff_g0}, \code{mean_eff_g1}: mean effectiveness per group
#'     \item \code{sd_cost_*}, \code{sd_eff_*}: standard deviations per group
#'     \item \code{delta_cost}, \code{delta_effect}, \code{ICER}: incremental estimates
#'     \item \code{NMB_*}: Net Monetary Benefit for each specified `lambda`
#'   }
#'
#' @details
#' This summary provides descriptive context to the bootstrap analysis performed
#' by \code{\link{compute_icers}}. It is not based on bootstrap replications, but on
#' the raw data used as input for the cost-effectiveness analysis.
#'
#' @seealso
#' \code{\link{compute_icers}} for analytical bootstrap estimation of ICERs;
#' \code{\link{combine_icers_results}} for merging bootstrap replicates;
#' and the deprecated `summary.cea_results()` for legacy functionality.
#'
#' @examples
#' \dontrun{
#' data_list <- list(
#'   dataset_base = cua_base,
#'   dataset_discounted = cua_base_discounted
#' )
#' summarize_cea_data(
#'   data = data_list,
#'   group = "group",
#'   cost = "cost_total",
#'   effect = "effect",
#'   subgroup_vars = c("diabetes", "HTA"),
#'   lambda = c(25000, 35000)
#' )
#' }
#'
#' @importFrom dplyr summarise group_by bind_rows mutate n across
#' @importFrom tibble tibble
#' @export
summarize_cea_data <- function(data, group, cost, effect,
                               subgroup_vars = NULL, lambda = 25000) {

  summarize_one <- function(df, dataset_name) {

    # Helper to compute summary for a given subset (overall or subgroup)
    compute_summary <- function(sub_df, subgroup_var = "Overall", subgroup_level = NA) {

      sub_df[[group]] <- as.factor(sub_df[[group]])
      if (length(unique(sub_df[[group]])) < 2) return(NULL)

      # --- Compute means and SD per group ---
      means_cost <- tapply(sub_df[[cost]], sub_df[[group]], mean, na.rm = TRUE)
      sds_cost   <- tapply(sub_df[[cost]], sub_df[[group]], sd,   na.rm = TRUE)

      means_eff  <- tapply(sub_df[[effect]], sub_df[[group]], mean, na.rm = TRUE)
      sds_eff    <- tapply(sub_df[[effect]], sub_df[[group]], sd,   na.rm = TRUE)

      ns <- table(sub_df[[group]])

      # --- Incremental calculations ---
      delta_cost <- means_cost[2] - means_cost[1]
      delta_eff  <- means_eff[2] - means_eff[1]
      icer <- ifelse(delta_eff == 0, NA, delta_cost / delta_eff)

      nmb_values <- sapply(lambda, function(l) l * delta_eff - delta_cost)
      names(nmb_values) <- paste0("NMB_", lambda)

      tibble::tibble(
        dataset = dataset_name,
        subgroup_var = subgroup_var,
        subgroup_level = subgroup_level,
        n_g0 = as.integer(ns[1]),
        n_g1 = as.integer(ns[2]),
        mean_cost_g0 = as.numeric(means_cost[1]),
        sd_cost_g0   = as.numeric(sds_cost[1]),
        mean_cost_g1 = as.numeric(means_cost[2]),
        sd_cost_g1   = as.numeric(sds_cost[2]),
        mean_eff_g0  = as.numeric(means_eff[1]),
        sd_eff_g0    = as.numeric(sds_eff[1]),
        mean_eff_g1  = as.numeric(means_eff[2]),
        sd_eff_g1    = as.numeric(sds_eff[2]),
        delta_cost = delta_cost,
        delta_effect = delta_eff,
        ICER = icer,
        !!!as.list(nmb_values)
      )
    }

    # Overall summary
    overall_summary <- compute_summary(df, "Overall", NA)

    # Subgroup summaries (if specified)
    subgroup_summaries <- NULL
    if (!is.null(subgroup_vars)) {
      subgroup_summaries <- dplyr::bind_rows(lapply(subgroup_vars, function(var) {
        lvls <- unique(na.omit(df[[var]]))
        dplyr::bind_rows(lapply(lvls, function(lvl) {
          compute_summary(df[df[[var]] == lvl, , drop = FALSE],
                          subgroup_var = var,
                          subgroup_level = lvl)
        }))
      }))
    }

    dplyr::bind_rows(overall_summary, subgroup_summaries)
  }

  # Handle single dataset or list
  if (is.data.frame(data)) {
    summarize_one(data, "single_dataset")
  } else if (is.list(data)) {
    dplyr::bind_rows(lapply(names(data), function(ds_name) {
      summarize_one(data[[ds_name]], ds_name)
    }))
  } else {
    stop("`data` must be a data frame or a list of data frames.")
  }
}
